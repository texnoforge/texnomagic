{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TexnoMagic","text":"<p>TexnoMagic is a free and open source Python 3 library, CLI and format for symbol recognition and symbol-based language parsing.</p> <p>I created TexnoMagic after prototyping serveral systems for magic symbol recognition and invocation as well as systems for creating magic language based on symbols.</p> <p>You can read my posts about</p> <ul> <li>Theory of Magic</li> <li>Invocation of Magic</li> <li>Introducing TexnoMagic</li> <li>Words of Power</li> </ul> <p>to get a better idea of what I'm trying to achieve.</p> <p>See TexnoLatin reference alphabet.</p>"},{"location":"#status-alpha","title":"Status: alpha","text":"<p>alpha: working well, but interfaces aren't final yet</p> <p>JSON-RPC is currently broken on Python 3.12 due to <code>jsonrpcserver</code> / <code>oslash</code> dep breakage. <code>jsonrpcserver</code> is now an optional dep not installed by default to enable running of Python 3.12 before this gets fixed.</p> <p>TexnoMagic News</p>"},{"location":"#features","title":"Features","text":"<ul> <li>portable open format based on proven and widely supported standards:</li> <li>JSON for metadata</li> <li>CSV for symbol drawing data (fast and easy to parse)</li> <li>SVG for infinitely scalable symbol images</li> <li>provide consistent and practical directory structure</li> <li>save and load symbols to/from well-defined user files</li> <li>manage symbols in alphabets</li> <li>manage training data (drawings) for individual symbols</li> <li>download and use mods from wop.mod.io mod portal easily</li> <li>train symbol models from drawings</li> <li>currently uses Gaussian Mixture Models (GMM)</li> <li>neural networks support is possible</li> <li>use symbol models for real-time symbol recognition</li> <li>spell language parser based of Parsing Expression Grammars (PEG)</li> <li>tests, linting, CI</li> <li>proper python packaging, available from PyPI</li> <li>interfaces:</li> <li>Python module (<code>texnomagic</code>)</li> <li>Command-Line Interface (<code>texnomagic.cli</code>)</li> <li>simple TCP server using JSON-RPC (<code>texnomagic.server</code>) - universal interface</li> <li>\u26a0 format and API aren't final yet</li> <li>\u26a0 docs need more content</li> </ul>"},{"location":"#install","title":"Install","text":"<p>TexnoMagic is available from PyPI for Python 3.10+ (latest tested: 3.12):</p> <pre><code>pip install texnomagic\n</code></pre> <p>You can install / develop / build from source as with any other python module.</p> <pre><code>cd texnomagic\n\n# install from source\npip install .\n\n# install in --editable mode (great for development)\npip install -e .\n\n# isolated install using pipx\npipx install .\n\n# build package\npython -m build\n</code></pre>"},{"location":"#use","title":"Use","text":""},{"location":"#cli","title":"CLI \u2328\ufe0f","text":"<p>A full-featured <code>git</code>-like Command-Line Interface with colors support is available through <code>texnomagic</code> script.</p> <p>The <code>texnomagic</code> script should be installed by default, run it without arguments to get a summary of avaliable commands options:</p> <pre><code>$&gt; texnomagic\n\nUsage: texnomagic [OPTIONS] COMMAND [ARGS]...\n\n  TexnoMagic CLI\n\nOptions:\n  --version   Show TexnoMagic version and exit.\n  -h, --help  Show this message and exit.\n\nCommands:\n  abc      Manage TexnoMagic alphabets.\n  drawing  Manage TexnoMagic drawings.\n  mod      Manage Words of Power mods.\n  server   Start TexnoMagic TCP server on PORT.\n  spell    Parse and work with TexnoMagic Spells.\n  symbol   Manage TexnoMagic symbols.\n</code></pre> <p>Add <code>-h</code>/<code>--help</code> after a command to get usage for that command:</p> <pre><code>$&gt; texnomagic symbol -h\n\nUsage: texnomagic symbol [OPTIONS] COMMAND [ARGS]...\n\n  Manage TexnoMagic symbols.\n\nOptions:\n  -h, --help  Show command help.\n\nCommands:\n  list  List all symbols in a TexnoMagic alphabet.\n  new   Create a new TexnoMagic symbol.\n  show  Show details of a TexnoMagic symbol.\n</code></pre> <p>If your shell doesn't see the script (i.e. when not in <code>$PATH</code>), you can invoke the <code>texnomagic.cli</code> module directly:</p> <pre><code>$&gt; python -m texnomagic.cli list-abcs --full\n</code></pre>"},{"location":"#python","title":"Python \ud83d\udc0d","text":"<p>You can find code examples in:</p> <ul> <li>texnomagic/commands</li> <li>texnomagic/requests.py</li> <li>tests/</li> </ul>"},{"location":"#gui","title":"GUI \ud83d\uddb1\ufe0f","text":"<p>wopeditor is a project dedicated to providing comprehensive GUI for TexnoMagic.</p>"},{"location":"#godot-engine","title":"Godot Engine \u2699\ufe0f","text":"<p>wopeditor contains GDScript implementation of client for TexnoMagic server: wopeditor.client.</p> <p>You can use Godot's <code>JSONRPC</code> module to form requests and send them as strings using standard Godot networking which TexnoMagic adpoted (messages prefixed with 4 bytes of total message length).</p>"},{"location":"#json-rpc","title":"JSON-RPC \ud83c\udf0d","text":"<p>You can start universal language-agnostic JSON-RPC over TCP server using <code>texnomagic</code> CLI:</p> <pre><code>texnomagic server\n\n# optionally select a port\ntexnomagic server 12345\n</code></pre> <p>You can also invoke texnomagic.server module directly:</p> <pre><code>python -m texnomagic.server\n</code></pre> <p>It's also possible to compile stand-alone <code>texnomagic</code> binary using PyInstaller:</p> <pre><code>pyinstaller texnomagic.spec\n# results in dist/texnomagic\n</code></pre> <p>Simple reference python client is provided in texnomagic.client although it's only used for testing in TexnoMagic.</p> <p>For a full-fledged client implementation see wopeditor.client.</p>"},{"location":"#bugs-and-feature-requests","title":"Bugs and Feature Requests","text":"<p>Please use GitHub Issues to report any problems or feature requests.</p> <p>Contributions, suggestions, and ideas are always welcome \u2665</p>"},{"location":"#contact","title":"Contact","text":"<p>Feel free to drop by #wopeditor @ texnoforge discord.</p>"},{"location":"abc/","title":"TexnoMagic Alphabet","text":""},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet","title":"<code>TexnoMagicAlphabet</code>","text":"<p>TexnoMagic Alphabet is a set of Symbols.</p> <p>Alphabet has:</p> <ul> <li><code>name</code>: arbitrary string</li> <li><code>path</code>: path to Alphabet dir</li> <li><code>symbols</code>: a set of Symbols</li> </ul> <p>This class provides convenient utilities for working with TexnoMagic Alphabets, see individual methods.</p> Source code in <code>texnomagic/abc.py</code> <pre><code>class TexnoMagicAlphabet:\n    \"\"\"\n    TexnoMagic Alphabet is a set of [Symbols][texnomagic.symbol.TexnoMagicSymbol].\n\n    Alphabet has:\n\n    * `name`: arbitrary string\n    * `path`: path to Alphabet dir\n    * `symbols`: a set of Symbols\n\n    This class provides convenient utilities for working with TexnoMagic Alphabets,\n    see individual methods.\n    \"\"\"\n    def __init__(self, path=None, name=None):\n        if path and path.name.lower() == INFO_FILE:\n            # accept path to alphabet info file as well\n            path = path.parent\n\n        self.path = path\n        self.name = name\n        self._symbols = None\n\n    @property\n    def info_path(self) -&gt; Path:\n        f\"\"\"Path to Alphabet `{INFO_FILE}` info file.\"\"\"\n        return self.path / INFO_FILE\n\n    @property\n    def symbols_path(self) -&gt; Path:\n        \"\"\"Path to Alphabet `symbols` dir.\"\"\"\n        return self.path / 'symbols'\n\n    @property\n    def handle(self) -&gt; str:\n        \"\"\"Alphabet handle (lowercase string).\"\"\"\n        return common.name2handle(self.name)\n\n    @property\n    def symbols(self) -&gt; list[TexnoMagicSymbol]:\n        \"\"\"A list of Symbols in `drawings` dir.\n\n        Lazy loaded on-demand.\"\"\"\n        if self._symbols is None:\n            self.load_symbols()\n        return self._symbols\n\n    def load(self, path=None):\n        f\"\"\"Load Alphabet metadata from info file `{INFO_FILE}`.\"\"\"\n        if path:\n            self.path = path\n\n        assert self.path\n        info = json.load(self.info_path.open())\n\n        name = info.get('name')\n        if not name:\n            name = self.path.name\n        self.name = name\n\n        return self\n\n    def load_symbols(self):\n        \"\"\"Load Symbols from `symbols` dir.\"\"\"\n        self._symbols = []\n        for symbol_info_path in self.symbols_path.glob('*/texno_symbol.json'):\n            symbol = TexnoMagicSymbol()\n            symbol.load(symbol_info_path.parent)\n            self._symbols.append(symbol)\n        self.sort_symbols()\n\n    def sort_symbols(self):\n        \"\"\"Sort symbols with common ordering.\"\"\"\n        if not self._symbols:\n            return\n        known = []\n        for core_symbol in common.CORE_SYMBOLS_ORDER:\n            for symbol in self._symbols:\n                if symbol.meaning == core_symbol:\n                    known.append(symbol)\n                    self._symbols.remove(symbol)\n                    break\n        self._symbols = known + self._symbols\n\n    def save(self):\n        \"\"\"Save the Alphabet into path.\"\"\"\n        os.makedirs(self.path, exist_ok=True)\n        info = {\n            'name': self.name,\n        }\n        return json.dump(info, self.info_path.open('w'))\n\n    def save_new_symbol(self, symbol : TexnoMagicSymbol):\n        \"\"\"Save new Symbol into `symbols` dir.\"\"\"\n        assert symbol.name\n\n        if self._symbols is None:\n            self.load_symbols()\n\n        symbol.path = self.symbols_path / common.name2fn(symbol.name)\n        symbol.save()\n        return self._symbols.insert(0, symbol)\n\n    def export(self, out_path=None):\n        \"\"\"\n        Export alphabet into a zipfile.\n        \"\"\"\n        if not out_path:\n            out_path = common.EXPORT_PATH\n\n        ar_fn = self.path.name\n        out_fn = out_path / ar_fn\n        return shutil.make_archive(\n            out_fn, 'zip',\n            root_dir=self.path.parent,\n            base_dir=self.path.name,\n        )\n\n    def normalize(self):\n        \"\"\"Normalize all Symbols. Overwrites files.\n\n        See [texnomagic.drawing.TexnoMagicDrawing.normalize][].\"\"\"\n        for s in self.symbols:\n            s.normalize()\n\n    def train_models(self, all : bool = False):\n        \"\"\"Train symbol models with available drawings.\n\n        Train only missing models by default, use all to (re-)train all.\"\"\"\n        new, fail, old = [], [], []\n        for symbol in self.symbols:\n            if all or not symbol.model.ready:\n                if symbol.model.train_symbol(symbol):\n                    symbol.model.save()\n                    new.append(symbol)\n                else:\n                    fail.append(symbol)\n            else:\n                old.append(symbol)\n        return new, fail, old\n\n    def calibrate(self):\n        self.train_models(all=True)\n\n    def scores(self, drawing : TexnoMagicDrawing, reverse : bool = True) -&gt; list[tuple[TexnoMagicSymbol, float]]:\n        \"\"\"\n        Score a Drawing using all Symbol models.\n\n        Args:\n            drawing: a Symbol Drawing to score\n            reverse: reverse sorting order\n\n        Returns:\n            A list of (symbol, score) tuples ordered by score.\n        \"\"\"\n        s = [(symbol, symbol.model.score(drawing)) for symbol in self.symbols]\n        s = sorted(s, key=lambda x: x[1], reverse=reverse)\n        return s\n\n    def recognize(self, drawing : TexnoMagicDrawing) -&gt; tuple[TexnoMagicSymbol | None, float]:\n        \"\"\"\n        Recognize a Drawing within Alphabet Symbols.\n\n        Args:\n            drawing: a Symbol Drawing to recognize\n\n        Returns:\n            (symbol, score) tuple.\n        \"\"\"\n        s = self.scores(drawing)\n        if not s:\n            return None, -1\n        _symbol, score = s[0]\n        if score &lt; common.MIN_SCORE:\n            return None, score\n        return _symbol, score\n\n    def check(self):\n        \"\"\"Check alphabet for problems.\"\"\"\n        # NOTE: This needs a rewrite into something less ugly.\n        warns = dict()\n\n        def log_warn(key, val=1.0):\n            if key in warns:\n                n, v = warns[key]\n                warns[key] = (n + 1, (v * n + val) / (n + 1))\n            else:\n                warns[key] = (1, val)\n\n        for symbol in self.symbols:\n            if not symbol.model.ready:\n                log_warn(('warn', 'missing_model', symbol), -1)\n            if not symbol.get_image_path().exists():\n                log_warn(('warn', 'missing_svg', symbol), -1)\n            for drawing in symbol.drawings:\n                scores = self.scores(drawing)\n                rsymbol, rscore = scores[0]\n                if rsymbol.meaning != symbol.meaning:\n                    log_warn(('error', 'wrong_symbol', symbol, rsymbol), rscore)\n                    prob = 'wrong_symbol'\n                if rscore &lt; common.MIN_SCORE:\n                    log_warn(('warn', 'low_score', symbol), rscore)\n\n                for rsy, rsc in scores[1:]:\n                    # check scores for other symbols too\n                    if rsc &gt; 0.6:\n                        lvl = 'warn'\n                        if rsc &gt; 0.8:\n                            lvl = 'error'\n                        log_warn((lvl, 'high_score', symbol, rsy), rsc)\n\n        results = {}\n        for (level, prob, *args), (n, score) in warns.items():\n            if prob == 'high_score':\n                msg = \"%s drawing got high score in %s: %s\" % (args[0].meaning, args[1].meaning, score)\n            elif prob == 'low_score':\n                msg = \"%s drawing got low score: %s\" % (args[0].meaning, score)\n            elif prob == 'missing_model':\n                msg = \"%s symbol is missing model\" % args[0].meaning\n            elif prob == 'missing_svg':\n                msg = \"%s symbol is missing SVG image\" % args[0].meaning\n            else:\n                msg = \"%s drawing recognized as %s: %s\" % (args[0].meaning, args[1].meaning, score)\n            if n &gt; 1:\n                msg += \"  (x%s)\" % n\n            if level not in results:\n                results[level] = []\n            results[level].append(msg)\n\n        return results\n\n    def get_symbol(self, name : str) -&gt; TexnoMagicSymbol | None:\n        \"\"\"Get Symbol by name or meaning.\"\"\"\n        for s in self.symbols:\n            if s.name == name or s.meaning == name:\n                return s\n        return None\n\n    def random_symbol(self, exclude=None) -&gt; TexnoMagicSymbol | None:\n        \"\"\"Get a random Symbol from the Alphabet.\"\"\"\n        if exclude:\n            symbols = [s for s in self.symbols if s != exclude]\n        else:\n            symbols = self.symbols\n        if len(symbols) &lt; 1:\n            return None\n        return random.choice(symbols)\n\n    def gen_readme_md(self, heading=3):\n        \"\"\"\n        Generate Markdown for alphabet README.md\n        \"\"\"\n        htxt = heading * '#'\n        txt_ref = ''\n        txt_body = ''\n        for s in self.symbols:\n            img_path = PurePosixPath().joinpath(*s.get_image_path().parts[-4:])\n            stxt = (f\"{htxt} {s}\\n\\n\"\n                    f\"![{s}]({img_path})\\n\")\n            if len(s.drawings) &gt; 0:\n                d_path = PurePosixPath().joinpath(*s.drawings_path.parts[-3:])\n                stxt += f'\\n{len(s.drawings)} [drawings]({d_path})\\n'\n\n            txt_ref += f\"* [{s}](#{s.name}-{s.meaning.lower()})\\n\"\n            txt_body += stxt + '\\n'\n\n        txt = f\"**{len(self.symbols)}** symbols:\\n\\n{txt_ref}\\n{txt_body}\"\n        return txt.rstrip()\n\n    def as_dict(self, symbols=True) -&gt; dict:\n        \"\"\"Return Alphabet as a dict.\"\"\"\n        d = {\n            'name': self.name,\n            'handle': self.handle,\n            'path': str(self.path),\n            'n_symbols': len(self.symbols),\n        }\n        if symbols:\n            d['symbols'] = [s.meaning for s in self.symbols]\n        return d\n\n    def pretty(self, path=False):\n        \"\"\"Pretty Alphabet string with colors in rich formatting.\"\"\"\n        s = f'[cyan]{self.name}[/]: [white]{len(self.symbols)}[/] symbols'\n        if path:\n            s += f' @ [white]{self.path}[/]'\n        return s\n\n    def __str__(self):\n        return f'{self.name}: {len(self.symbols)} symbols'\n\n    def __repr__(self):\n        return f\"&lt;TexnoMagicAlphabet: {self.__str__()}&gt;\"\n</code></pre>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.handle","title":"<code>handle: str</code>  <code>property</code>","text":"<p>Alphabet handle (lowercase string).</p>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.symbols","title":"<code>symbols: list[TexnoMagicSymbol]</code>  <code>property</code>","text":"<p>A list of Symbols in <code>drawings</code> dir.</p> <p>Lazy loaded on-demand.</p>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.symbols_path","title":"<code>symbols_path: Path</code>  <code>property</code>","text":"<p>Path to Alphabet <code>symbols</code> dir.</p>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.as_dict","title":"<code>as_dict(symbols=True)</code>","text":"<p>Return Alphabet as a dict.</p> Source code in <code>texnomagic/abc.py</code> <pre><code>def as_dict(self, symbols=True) -&gt; dict:\n    \"\"\"Return Alphabet as a dict.\"\"\"\n    d = {\n        'name': self.name,\n        'handle': self.handle,\n        'path': str(self.path),\n        'n_symbols': len(self.symbols),\n    }\n    if symbols:\n        d['symbols'] = [s.meaning for s in self.symbols]\n    return d\n</code></pre>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.check","title":"<code>check()</code>","text":"<p>Check alphabet for problems.</p> Source code in <code>texnomagic/abc.py</code> <pre><code>def check(self):\n    \"\"\"Check alphabet for problems.\"\"\"\n    # NOTE: This needs a rewrite into something less ugly.\n    warns = dict()\n\n    def log_warn(key, val=1.0):\n        if key in warns:\n            n, v = warns[key]\n            warns[key] = (n + 1, (v * n + val) / (n + 1))\n        else:\n            warns[key] = (1, val)\n\n    for symbol in self.symbols:\n        if not symbol.model.ready:\n            log_warn(('warn', 'missing_model', symbol), -1)\n        if not symbol.get_image_path().exists():\n            log_warn(('warn', 'missing_svg', symbol), -1)\n        for drawing in symbol.drawings:\n            scores = self.scores(drawing)\n            rsymbol, rscore = scores[0]\n            if rsymbol.meaning != symbol.meaning:\n                log_warn(('error', 'wrong_symbol', symbol, rsymbol), rscore)\n                prob = 'wrong_symbol'\n            if rscore &lt; common.MIN_SCORE:\n                log_warn(('warn', 'low_score', symbol), rscore)\n\n            for rsy, rsc in scores[1:]:\n                # check scores for other symbols too\n                if rsc &gt; 0.6:\n                    lvl = 'warn'\n                    if rsc &gt; 0.8:\n                        lvl = 'error'\n                    log_warn((lvl, 'high_score', symbol, rsy), rsc)\n\n    results = {}\n    for (level, prob, *args), (n, score) in warns.items():\n        if prob == 'high_score':\n            msg = \"%s drawing got high score in %s: %s\" % (args[0].meaning, args[1].meaning, score)\n        elif prob == 'low_score':\n            msg = \"%s drawing got low score: %s\" % (args[0].meaning, score)\n        elif prob == 'missing_model':\n            msg = \"%s symbol is missing model\" % args[0].meaning\n        elif prob == 'missing_svg':\n            msg = \"%s symbol is missing SVG image\" % args[0].meaning\n        else:\n            msg = \"%s drawing recognized as %s: %s\" % (args[0].meaning, args[1].meaning, score)\n        if n &gt; 1:\n            msg += \"  (x%s)\" % n\n        if level not in results:\n            results[level] = []\n        results[level].append(msg)\n\n    return results\n</code></pre>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.export","title":"<code>export(out_path=None)</code>","text":"<p>Export alphabet into a zipfile.</p> Source code in <code>texnomagic/abc.py</code> <pre><code>def export(self, out_path=None):\n    \"\"\"\n    Export alphabet into a zipfile.\n    \"\"\"\n    if not out_path:\n        out_path = common.EXPORT_PATH\n\n    ar_fn = self.path.name\n    out_fn = out_path / ar_fn\n    return shutil.make_archive(\n        out_fn, 'zip',\n        root_dir=self.path.parent,\n        base_dir=self.path.name,\n    )\n</code></pre>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.gen_readme_md","title":"<code>gen_readme_md(heading=3)</code>","text":"<p>Generate Markdown for alphabet README.md</p> Source code in <code>texnomagic/abc.py</code> <pre><code>def gen_readme_md(self, heading=3):\n    \"\"\"\n    Generate Markdown for alphabet README.md\n    \"\"\"\n    htxt = heading * '#'\n    txt_ref = ''\n    txt_body = ''\n    for s in self.symbols:\n        img_path = PurePosixPath().joinpath(*s.get_image_path().parts[-4:])\n        stxt = (f\"{htxt} {s}\\n\\n\"\n                f\"![{s}]({img_path})\\n\")\n        if len(s.drawings) &gt; 0:\n            d_path = PurePosixPath().joinpath(*s.drawings_path.parts[-3:])\n            stxt += f'\\n{len(s.drawings)} [drawings]({d_path})\\n'\n\n        txt_ref += f\"* [{s}](#{s.name}-{s.meaning.lower()})\\n\"\n        txt_body += stxt + '\\n'\n\n    txt = f\"**{len(self.symbols)}** symbols:\\n\\n{txt_ref}\\n{txt_body}\"\n    return txt.rstrip()\n</code></pre>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.get_symbol","title":"<code>get_symbol(name)</code>","text":"<p>Get Symbol by name or meaning.</p> Source code in <code>texnomagic/abc.py</code> <pre><code>def get_symbol(self, name : str) -&gt; TexnoMagicSymbol | None:\n    \"\"\"Get Symbol by name or meaning.\"\"\"\n    for s in self.symbols:\n        if s.name == name or s.meaning == name:\n            return s\n    return None\n</code></pre>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.load_symbols","title":"<code>load_symbols()</code>","text":"<p>Load Symbols from <code>symbols</code> dir.</p> Source code in <code>texnomagic/abc.py</code> <pre><code>def load_symbols(self):\n    \"\"\"Load Symbols from `symbols` dir.\"\"\"\n    self._symbols = []\n    for symbol_info_path in self.symbols_path.glob('*/texno_symbol.json'):\n        symbol = TexnoMagicSymbol()\n        symbol.load(symbol_info_path.parent)\n        self._symbols.append(symbol)\n    self.sort_symbols()\n</code></pre>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.normalize","title":"<code>normalize()</code>","text":"<p>Normalize all Symbols. Overwrites files.</p> <p>See texnomagic.drawing.TexnoMagicDrawing.normalize.</p> Source code in <code>texnomagic/abc.py</code> <pre><code>def normalize(self):\n    \"\"\"Normalize all Symbols. Overwrites files.\n\n    See [texnomagic.drawing.TexnoMagicDrawing.normalize][].\"\"\"\n    for s in self.symbols:\n        s.normalize()\n</code></pre>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.pretty","title":"<code>pretty(path=False)</code>","text":"<p>Pretty Alphabet string with colors in rich formatting.</p> Source code in <code>texnomagic/abc.py</code> <pre><code>def pretty(self, path=False):\n    \"\"\"Pretty Alphabet string with colors in rich formatting.\"\"\"\n    s = f'[cyan]{self.name}[/]: [white]{len(self.symbols)}[/] symbols'\n    if path:\n        s += f' @ [white]{self.path}[/]'\n    return s\n</code></pre>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.random_symbol","title":"<code>random_symbol(exclude=None)</code>","text":"<p>Get a random Symbol from the Alphabet.</p> Source code in <code>texnomagic/abc.py</code> <pre><code>def random_symbol(self, exclude=None) -&gt; TexnoMagicSymbol | None:\n    \"\"\"Get a random Symbol from the Alphabet.\"\"\"\n    if exclude:\n        symbols = [s for s in self.symbols if s != exclude]\n    else:\n        symbols = self.symbols\n    if len(symbols) &lt; 1:\n        return None\n    return random.choice(symbols)\n</code></pre>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.recognize","title":"<code>recognize(drawing)</code>","text":"<p>Recognize a Drawing within Alphabet Symbols.</p> <p>Parameters:</p> Name Type Description Default <code>drawing</code> <code>TexnoMagicDrawing</code> <p>a Symbol Drawing to recognize</p> required <p>Returns:</p> Type Description <code>tuple[TexnoMagicSymbol | None, float]</code> <p>(symbol, score) tuple.</p> Source code in <code>texnomagic/abc.py</code> <pre><code>def recognize(self, drawing : TexnoMagicDrawing) -&gt; tuple[TexnoMagicSymbol | None, float]:\n    \"\"\"\n    Recognize a Drawing within Alphabet Symbols.\n\n    Args:\n        drawing: a Symbol Drawing to recognize\n\n    Returns:\n        (symbol, score) tuple.\n    \"\"\"\n    s = self.scores(drawing)\n    if not s:\n        return None, -1\n    _symbol, score = s[0]\n    if score &lt; common.MIN_SCORE:\n        return None, score\n    return _symbol, score\n</code></pre>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.save","title":"<code>save()</code>","text":"<p>Save the Alphabet into path.</p> Source code in <code>texnomagic/abc.py</code> <pre><code>def save(self):\n    \"\"\"Save the Alphabet into path.\"\"\"\n    os.makedirs(self.path, exist_ok=True)\n    info = {\n        'name': self.name,\n    }\n    return json.dump(info, self.info_path.open('w'))\n</code></pre>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.save_new_symbol","title":"<code>save_new_symbol(symbol)</code>","text":"<p>Save new Symbol into <code>symbols</code> dir.</p> Source code in <code>texnomagic/abc.py</code> <pre><code>def save_new_symbol(self, symbol : TexnoMagicSymbol):\n    \"\"\"Save new Symbol into `symbols` dir.\"\"\"\n    assert symbol.name\n\n    if self._symbols is None:\n        self.load_symbols()\n\n    symbol.path = self.symbols_path / common.name2fn(symbol.name)\n    symbol.save()\n    return self._symbols.insert(0, symbol)\n</code></pre>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.scores","title":"<code>scores(drawing, reverse=True)</code>","text":"<p>Score a Drawing using all Symbol models.</p> <p>Parameters:</p> Name Type Description Default <code>drawing</code> <code>TexnoMagicDrawing</code> <p>a Symbol Drawing to score</p> required <code>reverse</code> <code>bool</code> <p>reverse sorting order</p> <code>True</code> <p>Returns:</p> Type Description <code>list[tuple[TexnoMagicSymbol, float]]</code> <p>A list of (symbol, score) tuples ordered by score.</p> Source code in <code>texnomagic/abc.py</code> <pre><code>def scores(self, drawing : TexnoMagicDrawing, reverse : bool = True) -&gt; list[tuple[TexnoMagicSymbol, float]]:\n    \"\"\"\n    Score a Drawing using all Symbol models.\n\n    Args:\n        drawing: a Symbol Drawing to score\n        reverse: reverse sorting order\n\n    Returns:\n        A list of (symbol, score) tuples ordered by score.\n    \"\"\"\n    s = [(symbol, symbol.model.score(drawing)) for symbol in self.symbols]\n    s = sorted(s, key=lambda x: x[1], reverse=reverse)\n    return s\n</code></pre>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.sort_symbols","title":"<code>sort_symbols()</code>","text":"<p>Sort symbols with common ordering.</p> Source code in <code>texnomagic/abc.py</code> <pre><code>def sort_symbols(self):\n    \"\"\"Sort symbols with common ordering.\"\"\"\n    if not self._symbols:\n        return\n    known = []\n    for core_symbol in common.CORE_SYMBOLS_ORDER:\n        for symbol in self._symbols:\n            if symbol.meaning == core_symbol:\n                known.append(symbol)\n                self._symbols.remove(symbol)\n                break\n    self._symbols = known + self._symbols\n</code></pre>"},{"location":"abc/#texnomagic.abc.TexnoMagicAlphabet.train_models","title":"<code>train_models(all=False)</code>","text":"<p>Train symbol models with available drawings.</p> <p>Train only missing models by default, use all to (re-)train all.</p> Source code in <code>texnomagic/abc.py</code> <pre><code>def train_models(self, all : bool = False):\n    \"\"\"Train symbol models with available drawings.\n\n    Train only missing models by default, use all to (re-)train all.\"\"\"\n    new, fail, old = [], [], []\n    for symbol in self.symbols:\n        if all or not symbol.model.ready:\n            if symbol.model.train_symbol(symbol):\n                symbol.model.save()\n                new.append(symbol)\n            else:\n                fail.append(symbol)\n        else:\n            old.append(symbol)\n    return new, fail, old\n</code></pre>"},{"location":"abc/#texnomagic.abc.find_alphabet_at_path","title":"<code>find_alphabet_at_path(path=None)</code>","text":"<p>Find Alphabet at path.</p> <p>When path is None, look at current path.</p> Source code in <code>texnomagic/abc.py</code> <pre><code>def find_alphabet_at_path(path=None) -&gt; TexnoMagicAlphabet:\n    \"\"\"Find Alphabet at path.\n\n    When path is None, look at current path.\"\"\"\n    info = common.find_file_at_parents(INFO_FILE, path)\n    if info:\n        return TexnoMagicAlphabet(info)\n    return None\n</code></pre>"},{"location":"cookbook/","title":"TexnoMagic Cookbook","text":"<p>A quick introduction to TexnoMagic Python module and CLI using examples.</p>"},{"location":"cookbook/#where-to-put-your-alphabets","title":"Where to put your Alphabets","text":"<p>Even though you can work with Alphabets at any location, it's convenient to put them into expected paths where TexnoMagic looks by default.</p> <p>You can view alphabets paths using CLI:</p> <p><pre><code>texnomagic paths\n</code></pre> <pre><code>user alphabets: /home/runner/.local/share/WordsOfPower/user/alphabets (exists)\nmods alphabets: /home/runner/.local/share/WordsOfPower/mods/alphabets (doesn't \nexist)\n</code></pre></p> <p>It's recommended to use the <code>user</code> path for your Alphabets.</p> <p>You can create and list <code>user</code> alphabets dir using CLI:</p> <p><pre><code>texnomagic paths --abcs user --mkdir\n</code></pre> <pre><code>/home/runner/.local/share/WordsOfPower/user/alphabets\n</code></pre></p> <p>Or open the dir using system file explorer:</p> <pre><code>texnomagic paths -a user -o\n</code></pre>"},{"location":"cookbook/#get-an-alphabet-texnolatin","title":"Get an Alphabet (TexnoLatin)","text":"<p>We'll be working with TexnoLatin reference Alphabet in all the examples and it's used for TexnoMagic testing as well.</p> <p>Here's some <code>bash</code> to clone latest TexnoLatin into expected <code>user</code> path:</p> <pre><code>cd $(texnomagic paths --abcs user --mkdir)\ngit clone https://github.com/texnoforge/texnolatin/\n</code></pre> <p>Ensure the Alphabet is visible:</p> <p><pre><code>texnomagic abc list\n</code></pre> <pre><code># 1 user alphabets @ /home/runner/.local/share/WordsOfPower/user/alphabets\nTexnoLatin: 24 symbols\n</code></pre></p>"},{"location":"cookbook/#load-alphabet","title":"Load Alphabet","text":"<p>It's recommended to access individual Symbols and Drawings (data) through TexnoMagicAlphabet class.</p>"},{"location":"cookbook/#load-alphabet-from-standard-paths","title":"Load Alphabet from standard paths","text":"<p>All further examples use <code>get_alphabet_or_fail</code> helper function to quickly get <code>TexnoMagicAlphabet</code> instance from standard paths by name like this:</p> <pre><code>from texnomagic.cli_common import get_alphabet_or_fail\n\nabc = get_alphabet_or_fail(\"texnolatin\")\n\nprint(abc)\n</code></pre> <pre><code>TexnoLatin: 24 symbols\n</code></pre> <p><code>get_alphabet_or_fail</code> is a convenience wrapper which auto-loads the Alphabet or prints a pretty error message and exists when Alphabet isn't found.</p> <p>See texnomagic/cli_common.py for details and inspiration.</p>"},{"location":"cookbook/#load-alphabet-from-current-dir","title":"Load Alphabet from current dir","text":"<p>You can use <code>get_alphabet_or_fail</code> without <code>path</code> argument to look for an Alphabet in current directory and its parents:</p> <pre><code>from texnomagic.cli_common import get_alphabet_or_fail\n\nabc = get_alphabet_or_fail()\n</code></pre> <p>Or you can use <code>find_alphabet_at_path</code> directly to search any path:</p> <pre><code>from pathlib import Path\nfrom texnomagic.abc import find_alphabet_at_path\n\nabc_path = Path('alphabets/texnolatin/symbols/fire')\nabc = find_alphabet_at_path(abc_path)\nabc.load()\n\nprint(abc)\n</code></pre> <pre><code>TexnoLatin: 24 symbols\n</code></pre>"},{"location":"cookbook/#load-alphabet-from-any-path","title":"Load Alphabet from any path","text":"<p>You can load Alphabet directly by passing its <code>path</code> to TexnoMagicAlphabet and calling <code>load</code> method:</p> <pre><code>from pathlib import Path\nfrom texnomagic.abc import TexnoMagicAlphabet\n\nabc_path = Path('alphabets/texnolatin')\nabc = TexnoMagicAlphabet(path=abc_path)\nabc.load()\n\nprint(abc)\n</code></pre> <pre><code>TexnoLatin: 24 symbols\n</code></pre>"},{"location":"cookbook/#list-symbols-from-alphabet","title":"List Symbols from Alphabet","text":"<p>CLI:</p> <p><pre><code>texnomagic symbol list texnolatin\n</code></pre> <pre><code># 24 symbols @ \n/home/runner/.local/share/WordsOfPower/user/alphabets/texnolatin/symbols\nignis (fire): SVG image, 29 drawings, GMM model (n_gauss: 8, score_avg: -12.9)\ngelu (ice): SVG image, 29 drawings, GMM model (n_gauss: 9, score_avg: -12.7)\naqua (water): SVG image, 24 drawings, GMM model (n_gauss: 12, score_avg: -11.6)\naer (air): SVG image, 48 drawings, GMM model (n_gauss: 10, score_avg: -12.3)\nfulgur (electro): SVG image, 39 drawings, GMM model (n_gauss: 5, score_avg: \n-12.3)\nterra (earth): SVG image, 27 drawings, GMM model (n_gauss: 4, score_avg: -12.2)\nvita (life): SVG image, 37 drawings, GMM model (n_gauss: 4, score_avg: -12.4)\nmors (death): SVG image, 28 drawings, GMM model (n_gauss: 4, score_avg: -12.5)\nsagitta (bolt): SVG image, 39 drawings, GMM model (n_gauss: 2, score_avg: -11.9)\nsphaera (ball): SVG image, 34 drawings, GMM model (n_gauss: 8, score_avg: -11.7)\nspatium (space): SVG image, 30 drawings, GMM model (n_gauss: 16, score_avg: \n-12.3)\nconus (cone): SVG image, 29 drawings, GMM model (n_gauss: 5, score_avg: -12.2)\ntorrens (beam): SVG image, 22 drawings, GMM model (n_gauss: 8, score_avg: -11.7)\nego (self): SVG image, 29 drawings, GMM model (n_gauss: 14, score_avg: -12.5)\namica (friend): SVG image, 42 drawings, GMM model (n_gauss: 7, score_avg: -12.5)\nhostis (enemy): SVG image, 38 drawings, GMM model (n_gauss: 7, score_avg: -12.6)\nprope (close): SVG image, 27 drawings, GMM model (n_gauss: 2, score_avg: -12.0)\nprocul (far): SVG image, 45 drawings, GMM model (n_gauss: 2, score_avg: -12.0)\nfortis (strong): SVG image, 31 drawings, GMM model (n_gauss: 8, score_avg: \n-12.3)\ninfirmus (weak): SVG image, 25 drawings, GMM model (n_gauss: 8, score_avg: \n-12.2)\nmagnus (big): SVG image, 39 drawings, GMM model (n_gauss: 3, score_avg: -12.6)\nparvus (small): SVG image, 32 drawings, GMM model (n_gauss: 3, score_avg: -12.7)\nceler (fast): SVG image, 31 drawings, GMM model (n_gauss: 6, score_avg: -12.8)\ntardus (slow): SVG image, 35 drawings, GMM model (n_gauss: 6, score_avg: -12.5)\n</code></pre></p> <p>Python:</p> <pre><code>from texnomagic.cli_common import get_alphabet_or_fail\n\nabc = get_alphabet_or_fail(\"texnolatin\")\nfor symbol in abc.symbols:\n    print(symbol)\n</code></pre> <pre><code>ignis (fire)\ngelu (ice)\naqua (water)\naer (air)\nfulgur (electro)\nterra (earth)\nvita (life)\nmors (death)\nsagitta (bolt)\nsphaera (ball)\nspatium (space)\nconus (cone)\ntorrens (beam)\nego (self)\namica (friend)\nhostis (enemy)\nprope (close)\nprocul (far)\nfortis (strong)\ninfirmus (weak)\nmagnus (big)\nparvus (small)\nceler (fast)\ntardus (slow)\n</code></pre>"},{"location":"cookbook/#list-drawings-of-symbol","title":"List Drawings of Symbol","text":"<p>Use <code>ALPHABET:SYMBOL</code> syntax to select a specific Symbol.</p> <p>CLI:</p> <p><pre><code>texnomagic drawing list texnolatin/fire\n</code></pre> <pre><code>fire_1709239728798.csv: 227 points, 1 curves, 8 kB\nfire_1709588014524.csv: 110 points, 1 curves, 4 kB\nfire_1709501601465.csv: 92 points, 1 curves, 4 kB\nfire_1709332562598.csv: 711 points, 1 curves, 26 kB\nfire_1710079121173.csv: 466 points, 4 curves, 17 kB\nfire_1709229817510.csv: 115 points, 1 curves, 5 kB\nfire_1709471244496.csv: 105 points, 1 curves, 4 kB\nfire_1709229788382.csv: 135 points, 1 curves, 5 kB\nfire_1709332548305.csv: 480 points, 1 curves, 18 kB\nfire_1709478169231.csv: 132 points, 1 curves, 5 kB\nfire_1709416663416.csv: 127 points, 1 curves, 5 kB\nfire_1709501625734.csv: 201 points, 1 curves, 8 kB\nfire_1709332604781.csv: 432 points, 1 curves, 16 kB\nfire_1709416630930.csv: 113 points, 1 curves, 4 kB\nfire_1709538199887.csv: 211 points, 1 curves, 8 kB\nfire_1709416667312.csv: 115 points, 1 curves, 4 kB\nfire_1709501509004.csv: 110 points, 1 curves, 4 kB\nfire_1709229865605.csv: 98 points, 1 curves, 4 kB\nfire_1709571045075.csv: 62 points, 1 curves, 3 kB\nfire_1709231416786.csv: 51 points, 1 curves, 2 kB\nfire_1709571040678.csv: 64 points, 1 curves, 3 kB\nfire_1710023927370.csv: 104 points, 1 curves, 4 kB\nfire_1710079109175.csv: 512 points, 2 curves, 19 kB\nfire_1709332540122.csv: 698 points, 1 curves, 25 kB\nfire_1709231398891.csv: 55 points, 1 curves, 2 kB\nfire_1709416639519.csv: 125 points, 1 curves, 5 kB\nfire_1709538240512.csv: 148 points, 1 curves, 6 kB\nfire_1709321796565.csv: 242 points, 1 curves, 9 kB\nfire_1709334725070.csv: 443 points, 1 curves, 16 kB\n\naverage: 223.6 points, 1.1 curves, 7 kB\n\ntotal: 6484.0 points, 33.0 curves, 227 kB, 29 drawings\n</code></pre></p> <p>Python:</p> <pre><code>from texnomagic.cli_common import get_alphabet_or_fail\n\nabc = get_alphabet_or_fail(\"texnolatin\")\nsymbol = abc.get_symbol(\"fire\")\nfor drawing in symbol.drawings:\n    drawing.load_curves()\n    print(drawing)\n</code></pre> <pre><code>fire_1709239728798.csv: 227 points, 1 curves\nfire_1709588014524.csv: 110 points, 1 curves\nfire_1709501601465.csv: 92 points, 1 curves\nfire_1709332562598.csv: 711 points, 1 curves\nfire_1710079121173.csv: 466 points, 4 curves\nfire_1709229817510.csv: 115 points, 1 curves\nfire_1709471244496.csv: 105 points, 1 curves\nfire_1709229788382.csv: 135 points, 1 curves\nfire_1709332548305.csv: 480 points, 1 curves\nfire_1709478169231.csv: 132 points, 1 curves\nfire_1709416663416.csv: 127 points, 1 curves\nfire_1709501625734.csv: 201 points, 1 curves\nfire_1709332604781.csv: 432 points, 1 curves\nfire_1709416630930.csv: 113 points, 1 curves\nfire_1709538199887.csv: 211 points, 1 curves\nfire_1709416667312.csv: 115 points, 1 curves\nfire_1709501509004.csv: 110 points, 1 curves\nfire_1709229865605.csv: 98 points, 1 curves\nfire_1709571045075.csv: 62 points, 1 curves\nfire_1709231416786.csv: 51 points, 1 curves\nfire_1709571040678.csv: 64 points, 1 curves\nfire_1710023927370.csv: 104 points, 1 curves\nfire_1710079109175.csv: 512 points, 2 curves\nfire_1709332540122.csv: 698 points, 1 curves\nfire_1709231398891.csv: 55 points, 1 curves\nfire_1709416639519.csv: 125 points, 1 curves\nfire_1709538240512.csv: 148 points, 1 curves\nfire_1709321796565.csv: 242 points, 1 curves\nfire_1709334725070.csv: 443 points, 1 curves\n</code></pre>"},{"location":"cookbook/#render-drawing-as-a-raster-image","title":"Render Drawing as a raster Image","text":"<p>You can render any Drawing into a <code>PIL.Image</code> for display or further processing.</p> <p>To display a Drawing in 200x200 pixels resolution:</p> <p>CLI</p> <pre><code>texnomagic drawing render -r 200 alphabets/texnolatin/symbols/fire/drawings/fire_1709229865605.csv\n</code></pre> <p>Python:</p> <pre><code>from texnomagic.cli_common import get_alphabet_or_fail\nfrom texnomagic.render import render_drawing\n\nabc = get_alphabet_or_fail(\"texnolatin\")\nsymbol = abc.get_symbol(\"friend\")\ndrawing = symbol.random_drawing()\nimage = render_drawing(drawing, res=200)\nprint(image)\n</code></pre> <pre><code>&lt;PIL.Image.Image image mode=L size=200x200 at 0x7F2D5020A330&gt;\n</code></pre> <p>You can also display the image interactively:</p> <pre><code>image.show()\n</code></pre> <p>Or save it to a PNG file:</p> <pre><code>image.save('fire.png')\n</code></pre> <p>You can also easily convert the image into <code>numpy.array</code> and do what you want with it, for example use it to train neural networks using your own code:</p> <pre><code>import numpy as np\n\nfrom texnomagic.cli_common import get_alphabet_or_fail\nfrom texnomagic.render import render_drawing\n\nabc = get_alphabet_or_fail(\"texnolatin\")\nsymbol = abc.get_symbol(\"friend\")\ndrawing = symbol.random_drawing()\nimage = render_drawing(drawing, res=16)\nimage_array = np.array(image)\nprint(f'Array shape: {image_array.shape}')\nprint(image_array)\n</code></pre> <pre><code>Array shape: (16, 16)\n[[  0   0   0   0   0 255   0   0   0   0 255   0   0   0   0   0]\n [  0   0   0   0   0 255   0   0   0   0 255   0   0   0   0   0]\n [  0   0   0   0   0 255   0   0   0   0 255   0   0   0   0   0]\n [  0   0   0   0   0 255   0   0   0   0 255   0   0   0   0   0]\n [  0   0   0   0   0 255   0   0   0   0 255   0   0   0   0   0]\n [  0   0   0   0   0 255   0   0   0   0 255   0   0   0   0   0]\n [  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n [  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n [255 255   0   0   0   0   0   0   0   0   0   0   0   0   0 255]\n [  0 255   0   0   0   0   0   0   0   0   0   0   0   0 255 255]\n [  0 255   0   0   0   0   0   0   0   0   0   0   0   0 255   0]\n [  0 255   0   0   0   0   0   0   0   0   0   0   0   0 255   0]\n [  0 255 255   0   0   0   0   0   0   0   0   0   0 255 255   0]\n [  0   0 255 255   0   0   0   0   0   0   0 255 255 255   0   0]\n [  0   0   0 255 255 255   0   0   0   0 255 255   0   0   0   0]\n [  0   0   0   0   0 255 255 255 255 255 255   0   0   0   0   0]]\n</code></pre>"},{"location":"drawing/","title":"TexnoMagic Drawing","text":""},{"location":"drawing/#texnomagic.drawing.TexnoMagicDrawing","title":"<code>TexnoMagicDrawing</code>","text":"<p>TexnoMagic Drawing is a set of 2D curves defined by points.</p> <p>Specifically, Drawing is list of lists of 2D points (a list of separated curves) as generated by pointing devices such as mouse, touch, and tablets.</p> <p>This abstraction is roughly equivalent to using a pen &amp; paper. Individual drawing points indicate the trajectory of a pen/pencil/marker/brush/chalk/etc when it was writing.</p> <p>Drawing is a usually a representation of a Symbol.</p> <p>Drawings are stored as CSV files with individual curves separated by empty lines (<code>,</code>).</p> <p><code>self.path</code> is a path of Drawing data CSV file.</p> <p>This class provides convenient utilities for working with Drawings, see individual methods.</p> Source code in <code>texnomagic/drawing.py</code> <pre><code>class TexnoMagicDrawing:\n    \"\"\"TexnoMagic Drawing is a set of 2D curves defined by points.\n\n    Specifically, Drawing is list of lists of 2D points (a list of separated\n    curves) as generated by pointing devices such as mouse, touch, and tablets.\n\n    This abstraction is roughly equivalent to using a pen &amp; paper.\n    Individual drawing points indicate the trajectory of a\n    pen/pencil/marker/brush/chalk/etc when it was writing.\n\n    Drawing is a usually a representation of a\n    [Symbol][texnomagic.symbol.TexnoMagicSymbol].\n\n    Drawings are stored as CSV files with individual curves separated\n    by empty lines (`,`).\n\n    `self.path` is a path of Drawing data CSV file.\n\n    This class provides convenient utilities for working with Drawings,\n    see individual methods.\n    \"\"\"\n\n    def __init__(self, path=None, curves=None, points_range=1000.0):\n        self.path = path\n        self.points_range = points_range\n        self._curves = None\n        self._points = None\n        self._file_size = None\n        if curves:\n            self.set_curves(curves)\n\n    @property\n    def curves(self) -&gt; list[np.array]:\n        \"\"\"Individual curves (lists of points).\n\n        Lazy loaded on-demand.\"\"\"\n        if self._curves is None:\n            self.load_curves()\n        return self._curves\n\n    @property\n    def points(self) -&gt; np.array:\n        \"\"\"All points from all curves.\n\n        Lazy loaded on-demand.\"\"\"\n        if self._points is None:\n            self.load_curves()\n        return self._points\n\n    @property\n    def name(self) -&gt; str | None:\n        \"\"\"Drawing file name.\n\n        Derived from self.path.\"\"\"\n        if self.path:\n            return self.path.name\n        return None\n\n    @property\n    def file_size(self) -&gt; int:\n        \"\"\"Drawing file size.\n\n        Lazy loaded on-demand.\"\"\"\n        if self._file_size is None:\n            self._file_size = self.path.stat().st_size\n        return self._file_size\n\n    def set_curves(self, curves):\n        \"\"\"Assign curves.\n\n        Converts to a single numpy.array points with curves being views\n        into the array for fast processing.\"\"\"\n        # keep all points in single continuous numpy array\n        self._points = np.array(list(itertools.chain(*curves)), dtype=np.float64)\n        self._curves = []\n        i = 0\n        for curve in curves:\n            n = len(curve)\n            # curves are numpy views into main points array\n            cview = self._points[i:i+n]\n            self._curves.append(cview)\n            i += n\n\n    def load(self, path=None):\n        # this is only kept for consistence with symbol and abc\n        if path:\n            self.path = path\n        return self\n\n    def load_curves(self):\n        \"\"\"Load Drawing curves from file.\"\"\"\n        curves = []\n        curve = []\n        with self.path.open('r') as f:\n            reader = csv.reader(f)\n            for row in reader:\n                if not row or '' in row:\n                    # empty rows separate individual curves\n                    curves.append(curve)\n                    curve = []\n                    continue\n                point = list(map(float, row[:2]))\n                curve.append(point)\n        curves.append(curve)\n        self.set_curves(curves)\n\n    def save(self):\n        \"\"\"Save drawing to CSV file specified by self.path.\"\"\"\n        self.path.parent.mkdir(parents=True, exist_ok=True)\n        with self.path.open('w', newline='') as f:\n            writer = csv.writer(f)\n            first = True\n            for curve in self.curves:\n                if first:\n                    first = False\n                else:\n                    # curves separator\n                    writer.writerow([None, None])\n                writer.writerows(curve.tolist())\n\n    def normalize(self):\n        \"\"\"\n        Normalize drawing points in-place into &lt;0, self.points_range&gt; range.\n\n        See also [curves_fit_area][texnomagic.drawing.TexnoMagicDrawing.curves_fit_area].\n        \"\"\"\n        if len(self.points) == 0:\n            return\n\n        # move to [0,0]\n        self._points -= np.min(self.points, axis=0)\n        # normalize\n        k = self.points_range / np.max((np.max(np.max(self._points, axis=0)), 0.2))\n        self._points *= k\n        # center\n        offset = (self.points_range - np.max(self._points, axis=0)) / 2\n        self._points += offset\n\n    def curves_fit_area(self, pos : tuple[float, float] | npt.ArrayLike, size : tuple[float, float] | npt.ArrayLike) -&gt; list[npt.ArrayLike]:\n        \"\"\"\n        Return curves scaled to fit area.\n\n        Useful for drawing curves in UI\n\n        See also [normalize][texnomagic.drawing.TexnoMagicDrawing.normalize].\n\n        Args:\n          pos: position / offset (x, y) - relative &lt;0, 1&gt;\n          size: desired size (width, height) - relative &lt;0, 1&gt;\n\n        Returns:\n          Curves scaled to fit desired area.\n        \"\"\"\n        pos = np.array(pos)\n        size = np.array(size)\n\n        k = np.min(size) / self.points_range\n        max_range = self.points_range * k\n\n        offset = pos + (size - max_range) / 2\n\n        scurves = []\n        for curve in self.curves:\n            if len(curve) &gt; 0:\n                scurve = curve * k + offset\n            else:\n                scurve = curve\n            scurves.append(scurve)\n        return scurves\n\n    def flip_y_axis(self):\n        \"\"\"\n        Flip Drawing along Y axis in-place.\n\n        Useful for compatibility with systems that use different Y axis sign.\n        \"\"\"\n        self._points[:,1] = self.points_range - self._points[:,1]\n\n    def delete(self):\n        \"\"\"Delete the Drawing file.\"\"\"\n        if not self.path or not self.path.exists():\n            return\n        self.path.unlink()\n\n    def pretty(self, size=True) -&gt; str:\n        \"\"\"Pretty Drawing string with colors in rich formatting.\"\"\"\n        n_curves = len(self.curves)\n        n_points = len(self.points)\n        s = f\"[white bold]{self.path.name}[/]: \"\n        s += f\"{n_points} points, {n_curves} curves\"\n        if size:\n            fsize = math.ceil(self.file_size / 1024.0)\n            s += f\", {fsize} kB\"\n        return s\n\n    def __str__(self) -&gt; str:\n        if self._curves is None:\n            info = \"curves not loaded\"\n        else:\n            info = f\"{len(self._points)} points, {len(self._curves)} curves\"\n        return f\"{self.name}: {info}\"\n\n    def __repr__(self) -&gt; str:\n        return '&lt;TexnoMagicSymbol %s&gt;' % self.__str__()\n</code></pre>"},{"location":"drawing/#texnomagic.drawing.TexnoMagicDrawing.curves","title":"<code>curves: list[np.array]</code>  <code>property</code>","text":"<p>Individual curves (lists of points).</p> <p>Lazy loaded on-demand.</p>"},{"location":"drawing/#texnomagic.drawing.TexnoMagicDrawing.file_size","title":"<code>file_size: int</code>  <code>property</code>","text":"<p>Drawing file size.</p> <p>Lazy loaded on-demand.</p>"},{"location":"drawing/#texnomagic.drawing.TexnoMagicDrawing.name","title":"<code>name: str | None</code>  <code>property</code>","text":"<p>Drawing file name.</p> <p>Derived from self.path.</p>"},{"location":"drawing/#texnomagic.drawing.TexnoMagicDrawing.points","title":"<code>points: np.array</code>  <code>property</code>","text":"<p>All points from all curves.</p> <p>Lazy loaded on-demand.</p>"},{"location":"drawing/#texnomagic.drawing.TexnoMagicDrawing.curves_fit_area","title":"<code>curves_fit_area(pos, size)</code>","text":"<p>Return curves scaled to fit area.</p> <p>Useful for drawing curves in UI</p> <p>See also normalize.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>tuple[float, float] | ArrayLike</code> <p>position / offset (x, y) - relative &lt;0, 1&gt;</p> required <code>size</code> <code>tuple[float, float] | ArrayLike</code> <p>desired size (width, height) - relative &lt;0, 1&gt;</p> required <p>Returns:</p> Type Description <code>list[ArrayLike]</code> <p>Curves scaled to fit desired area.</p> Source code in <code>texnomagic/drawing.py</code> <pre><code>def curves_fit_area(self, pos : tuple[float, float] | npt.ArrayLike, size : tuple[float, float] | npt.ArrayLike) -&gt; list[npt.ArrayLike]:\n    \"\"\"\n    Return curves scaled to fit area.\n\n    Useful for drawing curves in UI\n\n    See also [normalize][texnomagic.drawing.TexnoMagicDrawing.normalize].\n\n    Args:\n      pos: position / offset (x, y) - relative &lt;0, 1&gt;\n      size: desired size (width, height) - relative &lt;0, 1&gt;\n\n    Returns:\n      Curves scaled to fit desired area.\n    \"\"\"\n    pos = np.array(pos)\n    size = np.array(size)\n\n    k = np.min(size) / self.points_range\n    max_range = self.points_range * k\n\n    offset = pos + (size - max_range) / 2\n\n    scurves = []\n    for curve in self.curves:\n        if len(curve) &gt; 0:\n            scurve = curve * k + offset\n        else:\n            scurve = curve\n        scurves.append(scurve)\n    return scurves\n</code></pre>"},{"location":"drawing/#texnomagic.drawing.TexnoMagicDrawing.delete","title":"<code>delete()</code>","text":"<p>Delete the Drawing file.</p> Source code in <code>texnomagic/drawing.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the Drawing file.\"\"\"\n    if not self.path or not self.path.exists():\n        return\n    self.path.unlink()\n</code></pre>"},{"location":"drawing/#texnomagic.drawing.TexnoMagicDrawing.flip_y_axis","title":"<code>flip_y_axis()</code>","text":"<p>Flip Drawing along Y axis in-place.</p> <p>Useful for compatibility with systems that use different Y axis sign.</p> Source code in <code>texnomagic/drawing.py</code> <pre><code>def flip_y_axis(self):\n    \"\"\"\n    Flip Drawing along Y axis in-place.\n\n    Useful for compatibility with systems that use different Y axis sign.\n    \"\"\"\n    self._points[:,1] = self.points_range - self._points[:,1]\n</code></pre>"},{"location":"drawing/#texnomagic.drawing.TexnoMagicDrawing.load_curves","title":"<code>load_curves()</code>","text":"<p>Load Drawing curves from file.</p> Source code in <code>texnomagic/drawing.py</code> <pre><code>def load_curves(self):\n    \"\"\"Load Drawing curves from file.\"\"\"\n    curves = []\n    curve = []\n    with self.path.open('r') as f:\n        reader = csv.reader(f)\n        for row in reader:\n            if not row or '' in row:\n                # empty rows separate individual curves\n                curves.append(curve)\n                curve = []\n                continue\n            point = list(map(float, row[:2]))\n            curve.append(point)\n    curves.append(curve)\n    self.set_curves(curves)\n</code></pre>"},{"location":"drawing/#texnomagic.drawing.TexnoMagicDrawing.normalize","title":"<code>normalize()</code>","text":"<p>Normalize drawing points in-place into &lt;0, self.points_range&gt; range.</p> <p>See also curves_fit_area.</p> Source code in <code>texnomagic/drawing.py</code> <pre><code>def normalize(self):\n    \"\"\"\n    Normalize drawing points in-place into &lt;0, self.points_range&gt; range.\n\n    See also [curves_fit_area][texnomagic.drawing.TexnoMagicDrawing.curves_fit_area].\n    \"\"\"\n    if len(self.points) == 0:\n        return\n\n    # move to [0,0]\n    self._points -= np.min(self.points, axis=0)\n    # normalize\n    k = self.points_range / np.max((np.max(np.max(self._points, axis=0)), 0.2))\n    self._points *= k\n    # center\n    offset = (self.points_range - np.max(self._points, axis=0)) / 2\n    self._points += offset\n</code></pre>"},{"location":"drawing/#texnomagic.drawing.TexnoMagicDrawing.pretty","title":"<code>pretty(size=True)</code>","text":"<p>Pretty Drawing string with colors in rich formatting.</p> Source code in <code>texnomagic/drawing.py</code> <pre><code>def pretty(self, size=True) -&gt; str:\n    \"\"\"Pretty Drawing string with colors in rich formatting.\"\"\"\n    n_curves = len(self.curves)\n    n_points = len(self.points)\n    s = f\"[white bold]{self.path.name}[/]: \"\n    s += f\"{n_points} points, {n_curves} curves\"\n    if size:\n        fsize = math.ceil(self.file_size / 1024.0)\n        s += f\", {fsize} kB\"\n    return s\n</code></pre>"},{"location":"drawing/#texnomagic.drawing.TexnoMagicDrawing.save","title":"<code>save()</code>","text":"<p>Save drawing to CSV file specified by self.path.</p> Source code in <code>texnomagic/drawing.py</code> <pre><code>def save(self):\n    \"\"\"Save drawing to CSV file specified by self.path.\"\"\"\n    self.path.parent.mkdir(parents=True, exist_ok=True)\n    with self.path.open('w', newline='') as f:\n        writer = csv.writer(f)\n        first = True\n        for curve in self.curves:\n            if first:\n                first = False\n            else:\n                # curves separator\n                writer.writerow([None, None])\n            writer.writerows(curve.tolist())\n</code></pre>"},{"location":"drawing/#texnomagic.drawing.TexnoMagicDrawing.set_curves","title":"<code>set_curves(curves)</code>","text":"<p>Assign curves.</p> <p>Converts to a single numpy.array points with curves being views into the array for fast processing.</p> Source code in <code>texnomagic/drawing.py</code> <pre><code>def set_curves(self, curves):\n    \"\"\"Assign curves.\n\n    Converts to a single numpy.array points with curves being views\n    into the array for fast processing.\"\"\"\n    # keep all points in single continuous numpy array\n    self._points = np.array(list(itertools.chain(*curves)), dtype=np.float64)\n    self._curves = []\n    i = 0\n    for curve in curves:\n        n = len(curve)\n        # curves are numpy views into main points array\n        cview = self._points[i:i+n]\n        self._curves.append(cview)\n        i += n\n</code></pre>"},{"location":"news/","title":"TexnoMagic News","text":""},{"location":"news/#texnomagic-080","title":"texnomagic 0.8.0","text":"<p>Released 2024-04-11</p>"},{"location":"news/#improvements","title":"Improvements","text":"<ul> <li><code>jsonrpcserver</code> dep is now optional, enabling Python &gt;= 3.12<ul> <li>Add Python 3.12 job to CI</li> </ul> </li> <li>new <code>texnomagic drawing recognize</code> command to recognize a Drawing<ul> <li>a powerful command with many useful options, see <code>--help</code></li> </ul> </li> <li>new <code>texnomagic drawing render</code> command to render Drawing to image such as PNG<ul> <li>only available when <code>pillow</code> module is installed</li> </ul> </li> <li>new commands to normalize Drawings:<ul> <li><code>texnomagic drawing normalize</code></li> <li><code>texnomagic symbol normalize</code></li> <li><code>texnomagic abc normalize</code></li> </ul> </li> <li>new <code>texnomagic paths</code> command to show/create/open alphabets paths</li> <li>new <code>-C</code>/<code>--color</code> global option to control output color</li> <li>new Drawing, Symbol, and Alphabet reference docs using <code>mkdocstrings</code><ul> <li>add docstrings and type hints - nicer code AND docs</li> <li>bump minimal Python to 3.10 due to typing improvements</li> </ul> </li> <li>new Cookbook doc with CLI and Python examples<ul> <li>executed using <code>markdown-exec</code> - always up-to-date</li> <li>CLI examples including ANSI color</li> </ul> </li> <li>better Symbol recognition tests</li> <li>various code and flow improvements</li> </ul>"},{"location":"news/#texnomagic-070","title":"texnomagic 0.7.0","text":"<p>Released 2024-02-29</p>"},{"location":"news/#improvements_1","title":"Improvements","text":"<ul> <li>new ergonomic Command-Line Interface (CLI)<ul> <li>structured modular commands as seen in <code>git</code></li> <li>dedicated command modules in <code>texnomagic.commands</code> for better modularity</li> </ul> </li> <li>terminal colors support using rich (new dep)</li> <li>basic symbol images support (<code>symbol.get_image_path()</code> and friends)</li> <li>improved symbol and alphabet representations and pretty printing</li> <li>improved python packaging using hatch through <code>pyproject.toml</code><ul> <li>update PyInstaller spec</li> </ul> </li> <li>improved CI<ul> <li>add Python 3.11 job</li> <li>separate lint job</li> </ul> </li> <li>improved and updated docs<ul> <li>add this news page</li> <li>mention current problems   with Python 3.12</li> <li>mention TexnoLation reference alphabet</li> <li>use mkdocs-material theme</li> </ul> </li> </ul>"},{"location":"symbol/","title":"TexnoMagic Symbol","text":""},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol","title":"<code>TexnoMagicSymbol</code>","text":"<p>TexnoMagic Symbol has:</p> <ul> <li><code>name</code>: arbitrary unicode string without spaces</li> <li><code>meaning</code>: english meaning in lowercase</li> <li><code>path</code>: path to Symbol dir</li> </ul> <p>Symbol can optionally contain:</p> <ul> <li><code>drawings</code>: a set of Drawings</li> <li><code>images</code>: images of the symbol in different formats (primary SVG)</li> <li><code>model</code>: model for symbol recognition</li> </ul> <p>Symbols usually reside within an Alphabet.</p> <p>This class provides convenient utilities for working with TexnoMagic Symbols, see individual methods.</p> Source code in <code>texnomagic/symbol.py</code> <pre><code>class TexnoMagicSymbol:\n    \"\"\"TexnoMagic Symbol has:\n\n    * `name`: arbitrary unicode string without spaces\n    * `meaning`: english meaning in lowercase\n    * `path`: path to Symbol dir\n\n    Symbol can optionally contain:\n\n    * `drawings`: a set of [Drawings][texnomagic.drawing.TexnoMagicDrawing]\n    * `images`: images of the symbol in different formats (primary SVG)\n    * `model`: model for symbol recognition\n\n    Symbols usually reside within an [Alphabet][texnomagic.abc.TexnoMagicAlphabet].\n\n    This class provides convenient utilities for working with TexnoMagic Symbols,\n    see individual methods.\n    \"\"\"\n    def __init__(self, path=None, meaning=None, name=None):\n        if path and path.name.lower() == INFO_FILE:\n            # accept path to symbol info file as well\n            path = path.parent\n\n        self.path = path\n        self.name = name\n        self.meaning = meaning\n        self._drawings = None\n        self._images = None\n        self._model = None\n\n    @property\n    def info_path(self) -&gt; Path:\n        f\"\"\"Path to Symbol `{INFO_FILE}` info file.\"\"\"\n        return self.path / INFO_FILE\n\n    @property\n    def drawings_path(self) -&gt; Path:\n        \"\"\"Path to Symbol `drawings` dir.\"\"\"\n        return self.path / 'drawings'\n\n    @property\n    def model_path(self) -&gt; Path:\n        \"\"\"Path to Symbol `model` dir.\"\"\"\n        return self.path / 'model'\n\n    @property\n    def image_base_path(self) -&gt; Path:\n        \"\"\"Path to Symbol `image` dir.\"\"\"\n        return self.path / 'image'\n\n    @property\n    def handle(self) -&gt; str:\n        \"\"\"Symbol handle (lowercase string).\"\"\"\n        return common.name2handle(self.name)\n\n    @property\n    def model(self) -&gt; TexnoMagicSymbolModel:\n        \"\"\"Symbol model.\n\n        Use `symbol.model.ready` to check if there is actually an usable model.\"\"\"\n        if self._model is None:\n            self.load_model()\n        return self._model\n\n    def get_image_path(self, format=common.IMAGE_FORMAT_DEFAULT) -&gt; Path:\n        return self.image_base_path / f'symbol.{format}'\n\n    def get_images(self) -&gt; dict:\n        imgs = {}\n        for format in common.IMAGE_FORMATS:\n            image_path = self.get_image_path(format=format)\n            if image_path.exists():\n                imgs[format] = image_path\n        return imgs\n\n    @property\n    def images(self) -&gt; dict:\n        \"\"\"A dict of available Symbol images with format as key.\"\"\"\n        if self._images is None:\n            self._images = self.get_images()\n        return self._images\n\n    def load(self, path=None):\n        f\"\"\"Load Symbol metadata from info file ({INFO_FILE}).\"\"\"\n        if path:\n            self.path = path\n\n        assert self.path\n        info = json.load(self.info_path.open())\n\n        name = info.get('name')\n        if not name:\n            name = self.path.name\n        self.name = name\n        self.meaning = info.get('meaning')\n\n        return self\n\n    def load_drawings(self):\n        \"\"\"Load Symbol drawings from `drawings` dir.\"\"\"\n        self._drawings = []\n        for drawing_path in self.drawings_path.glob('*'):\n            drawing = TexnoMagicDrawing()\n            drawing.load(drawing_path)\n            self._drawings.append(drawing)\n\n    def load_model(self):\n        \"\"\"Load Symbol model.\"\"\"\n        self._model = TexnoMagicSymbolModel(self.model_path)\n        self._model.load()\n\n    def train_model(self, n_gauss=0):\n        \"\"\"Train Symbol model from drawings.\"\"\"\n        if not self._model:\n            self._model = TexnoMagicSymbolModel(self.model_path)\n        if n_gauss:\n            self._model.n_gauss = n_gauss\n        return self._model.train_symbol(self)\n\n    def save(self):\n        \"\"\"Save the Symbol into path.\"\"\"\n        self.path.mkdir(parents=True, exist_ok=True)\n        info = {\n            'name': self.name,\n            'meaning': self.meaning,\n        }\n        return json.dump(info, self.info_path.open('w'))\n\n    def save_new_drawing(self, drawing):\n        \"\"\"Save new Drawing into `drawings` dir.\"\"\"\n        assert drawing\n\n        if self._drawings is None:\n            self.load_drawings()\n\n        fn = \"%s_%s.csv\" % (common.name2fn(self.name), int(time.time() * 1000))\n        drawing.path = self.drawings_path / fn\n        drawing.save()\n        return self._drawings.insert(0, drawing)\n\n    @property\n    def drawings(self) -&gt; list[TexnoMagicDrawing]:\n        \"\"\"A list of Symbol drawings in `drawings` dir.\n\n        Lazy loaded on-demand.\n        \"\"\"\n        if self._drawings is None:\n            self.load_drawings()\n        return self._drawings\n\n    def get_all_drawing_points(self) -&gt; np.array:\n        \"\"\"Get a list of all points from all drawings.\"\"\"\n        pp = [d.points for d in self.drawings]\n        if pp:\n            return np.concatenate(pp)\n        return np.array([])\n\n    def random_drawing(self) -&gt; TexnoMagicDrawing:\n        \"\"\"Get a random drawing.\"\"\"\n        if self.drawings:\n            return random.choice(self.drawings)\n        return None\n\n    def normalize(self):\n        \"\"\"Normalize all drawings. Overwrites files.\n\n        See [texnomagic.drawing.TexnoMagicDrawing.normalize].\"\"\"\n        for d in self.drawings:\n            if d.points.any():\n                d.normalize()\n                d.save()\n\n    def as_dict(self) -&gt; dict:\n        \"\"\"Return Symbol as a dict.\"\"\"\n        images = {f: str(p.relative_to(self.path)) for f, p in self.images.items()}\n        d = {\n            'name': self.name,\n            'meaning': self.meaning,\n            'path': str(self.path),\n            'n_drawings': len(self.drawings),\n            'images': images,\n        }\n        if self.model:\n            d['model'] = self.model.as_dict(relative_to=self.path)\n        return d\n\n    def pretty(self, drawings=False, images=False, model=False, path=False) -&gt; str:\n        \"\"\"Pretty Symbol string with colors in rich formatting.\"\"\"\n        s = f'[bright_green]{self.name}[/]'\n        if self.name != self.meaning:\n            s += f' ([green]{self.meaning}[/])'\n\n        extras = []\n        if images and self.images:\n            fmts = [f'[blue]{f.upper()}[/]' for f in self.images.keys()]\n            extras.append(f\"{', '.join(fmts)} image\")\n        if drawings and self.drawings:\n            extras.append(f'[white]{len(self.drawings)}[/] drawings')\n        if model and self.model.ready:\n            extras.append(f'{self.model.pretty()}')\n        if extras:\n            s += f\": {', '.join(extras)}\"\n\n        if path:\n            s += f' @ [white]{self.path}[/]'\n\n        return s\n\n    def __str__(self) -&gt; str:\n        return f'{self.name} ({self.meaning})'\n\n    def __repr__(self) -&gt; str:\n        return '&lt;TexnoMagicSymbol %s&gt;' % self.__str__()\n</code></pre>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.drawings","title":"<code>drawings: list[TexnoMagicDrawing]</code>  <code>property</code>","text":"<p>A list of Symbol drawings in <code>drawings</code> dir.</p> <p>Lazy loaded on-demand.</p>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.drawings_path","title":"<code>drawings_path: Path</code>  <code>property</code>","text":"<p>Path to Symbol <code>drawings</code> dir.</p>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.handle","title":"<code>handle: str</code>  <code>property</code>","text":"<p>Symbol handle (lowercase string).</p>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.image_base_path","title":"<code>image_base_path: Path</code>  <code>property</code>","text":"<p>Path to Symbol <code>image</code> dir.</p>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.images","title":"<code>images: dict</code>  <code>property</code>","text":"<p>A dict of available Symbol images with format as key.</p>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.model","title":"<code>model: TexnoMagicSymbolModel</code>  <code>property</code>","text":"<p>Symbol model.</p> <p>Use <code>symbol.model.ready</code> to check if there is actually an usable model.</p>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.model_path","title":"<code>model_path: Path</code>  <code>property</code>","text":"<p>Path to Symbol <code>model</code> dir.</p>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.as_dict","title":"<code>as_dict()</code>","text":"<p>Return Symbol as a dict.</p> Source code in <code>texnomagic/symbol.py</code> <pre><code>def as_dict(self) -&gt; dict:\n    \"\"\"Return Symbol as a dict.\"\"\"\n    images = {f: str(p.relative_to(self.path)) for f, p in self.images.items()}\n    d = {\n        'name': self.name,\n        'meaning': self.meaning,\n        'path': str(self.path),\n        'n_drawings': len(self.drawings),\n        'images': images,\n    }\n    if self.model:\n        d['model'] = self.model.as_dict(relative_to=self.path)\n    return d\n</code></pre>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.get_all_drawing_points","title":"<code>get_all_drawing_points()</code>","text":"<p>Get a list of all points from all drawings.</p> Source code in <code>texnomagic/symbol.py</code> <pre><code>def get_all_drawing_points(self) -&gt; np.array:\n    \"\"\"Get a list of all points from all drawings.\"\"\"\n    pp = [d.points for d in self.drawings]\n    if pp:\n        return np.concatenate(pp)\n    return np.array([])\n</code></pre>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.load_drawings","title":"<code>load_drawings()</code>","text":"<p>Load Symbol drawings from <code>drawings</code> dir.</p> Source code in <code>texnomagic/symbol.py</code> <pre><code>def load_drawings(self):\n    \"\"\"Load Symbol drawings from `drawings` dir.\"\"\"\n    self._drawings = []\n    for drawing_path in self.drawings_path.glob('*'):\n        drawing = TexnoMagicDrawing()\n        drawing.load(drawing_path)\n        self._drawings.append(drawing)\n</code></pre>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.load_model","title":"<code>load_model()</code>","text":"<p>Load Symbol model.</p> Source code in <code>texnomagic/symbol.py</code> <pre><code>def load_model(self):\n    \"\"\"Load Symbol model.\"\"\"\n    self._model = TexnoMagicSymbolModel(self.model_path)\n    self._model.load()\n</code></pre>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.normalize","title":"<code>normalize()</code>","text":"<p>Normalize all drawings. Overwrites files.</p> <p>See [texnomagic.drawing.TexnoMagicDrawing.normalize].</p> Source code in <code>texnomagic/symbol.py</code> <pre><code>def normalize(self):\n    \"\"\"Normalize all drawings. Overwrites files.\n\n    See [texnomagic.drawing.TexnoMagicDrawing.normalize].\"\"\"\n    for d in self.drawings:\n        if d.points.any():\n            d.normalize()\n            d.save()\n</code></pre>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.pretty","title":"<code>pretty(drawings=False, images=False, model=False, path=False)</code>","text":"<p>Pretty Symbol string with colors in rich formatting.</p> Source code in <code>texnomagic/symbol.py</code> <pre><code>def pretty(self, drawings=False, images=False, model=False, path=False) -&gt; str:\n    \"\"\"Pretty Symbol string with colors in rich formatting.\"\"\"\n    s = f'[bright_green]{self.name}[/]'\n    if self.name != self.meaning:\n        s += f' ([green]{self.meaning}[/])'\n\n    extras = []\n    if images and self.images:\n        fmts = [f'[blue]{f.upper()}[/]' for f in self.images.keys()]\n        extras.append(f\"{', '.join(fmts)} image\")\n    if drawings and self.drawings:\n        extras.append(f'[white]{len(self.drawings)}[/] drawings')\n    if model and self.model.ready:\n        extras.append(f'{self.model.pretty()}')\n    if extras:\n        s += f\": {', '.join(extras)}\"\n\n    if path:\n        s += f' @ [white]{self.path}[/]'\n\n    return s\n</code></pre>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.random_drawing","title":"<code>random_drawing()</code>","text":"<p>Get a random drawing.</p> Source code in <code>texnomagic/symbol.py</code> <pre><code>def random_drawing(self) -&gt; TexnoMagicDrawing:\n    \"\"\"Get a random drawing.\"\"\"\n    if self.drawings:\n        return random.choice(self.drawings)\n    return None\n</code></pre>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.save","title":"<code>save()</code>","text":"<p>Save the Symbol into path.</p> Source code in <code>texnomagic/symbol.py</code> <pre><code>def save(self):\n    \"\"\"Save the Symbol into path.\"\"\"\n    self.path.mkdir(parents=True, exist_ok=True)\n    info = {\n        'name': self.name,\n        'meaning': self.meaning,\n    }\n    return json.dump(info, self.info_path.open('w'))\n</code></pre>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.save_new_drawing","title":"<code>save_new_drawing(drawing)</code>","text":"<p>Save new Drawing into <code>drawings</code> dir.</p> Source code in <code>texnomagic/symbol.py</code> <pre><code>def save_new_drawing(self, drawing):\n    \"\"\"Save new Drawing into `drawings` dir.\"\"\"\n    assert drawing\n\n    if self._drawings is None:\n        self.load_drawings()\n\n    fn = \"%s_%s.csv\" % (common.name2fn(self.name), int(time.time() * 1000))\n    drawing.path = self.drawings_path / fn\n    drawing.save()\n    return self._drawings.insert(0, drawing)\n</code></pre>"},{"location":"symbol/#texnomagic.symbol.TexnoMagicSymbol.train_model","title":"<code>train_model(n_gauss=0)</code>","text":"<p>Train Symbol model from drawings.</p> Source code in <code>texnomagic/symbol.py</code> <pre><code>def train_model(self, n_gauss=0):\n    \"\"\"Train Symbol model from drawings.\"\"\"\n    if not self._model:\n        self._model = TexnoMagicSymbolModel(self.model_path)\n    if n_gauss:\n        self._model.n_gauss = n_gauss\n    return self._model.train_symbol(self)\n</code></pre>"}]}